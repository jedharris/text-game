# Codex Review

Scope: `src`, `behaviors`, `behavior_libraries`, `tests`, `examples`.

## src
- `src/action_types.py:10-27` still treats every object/indirect-object as `Optional[WordLike]` (a union of `WordEntry` and `str`). The downstream utilities insist on true `WordEntry` instances for synonym matching (`utilities/utils.py:118-140` and `259-340`), so the type system cannot prove safety and every handler has to assume `Any`. Consider normalizing inputs at the protocol edge and updating `ActionDict` to carry `WordEntry | None` so handlers can rely on vocabulary metadata without redundant casts/guards.
- `StateAccessor.get_actor` is typed as `def get_actor(self, actor_id: ActorId) -> Optional[Actor]` (`src/state_accessor.py:91-101`), yet virtually every call site passes a raw string (`behavior_libraries/crafting_lib/recipes.py:76`, `tests/test_phase3.py:79`, etc.), which is why the repo is littered with `# type: ignore[arg-type]`. Either accept `ActorId | str` (and coerce internally) or provide helper constructors so handlers/tests donâ€™t need to silence the checker.
- Entity behavior invocation only provides a bare `GameState` to handlers (`src/behavior_manager.py:784-790`), even though the newer authoring docs and multiple modules expect a full `StateAccessor`. As soon as a behavior (or one of the shipped examples) tries to call `accessor.get_actor(...)`, it crashes because it actually received `GameState`. Passing the accessor through (or exposing a thin wrapper with the supported API) would unlock typed access to helpers and align behavior authoring guidance with reality.
- Infrastructure helpers lean on the untyped `GameState.extra` bag. For example `get_commitment_config` (`src/infrastructure_utils.py:617-629`) reads untyped dicts while `create_commitment` (`src/infrastructure_utils.py:648-693`) writes `ActiveCommitment` entries that are only described via `TypedDict`. Because nothing enforces the shapes inside `extra`, mypy cannot help (every caller must `cast` or ignore types) and mistakes like missing keys are silently accepted. Consider introducing tiny dataclasses/Protocols for the structures stored in `extra` or accessor functions that return properly typed views.

## behaviors
- Core handlers still receive `ActionDict` without any type narrowing. For instance `behaviors/core/manipulation.py:91-204` reads `object_name = action.get("object")` and immediately passes it to helpers that expect a `WordEntry`, but nothing enforces that the key is present or of the right type. Once `ActionDict` is tightened, update these handlers to type-check (early `if not isinstance(object_name, WordEntry): ...`) instead of relying on assertions or runtime crashes.
- Entity-level behaviors under `behaviors/regions` (and several other subpackages) correctly follow the `(entity, state, context)` signature, but there is no typed alias/Protocol to help authors. Adding an `EventCallable` Protocol in `src/behavior_manager.py` (mirroring `HandlerCallable`) would let mypy reason about these modules and catch accidental signature drift.

## behavior_libraries
- Libraries frequently bypass the typed IDs and nullability guarantees. `behavior_libraries/crafting_lib/recipes.py:76-137` and `behavior_libraries/actor_lib/npc_actions.py:26-70` call `accessor.get_actor("player")` (or with other raw strings) and immediately dereference `.location`/`.properties` without checking for `None`. Switching to `ActorId("player")` and asserting the return value (or raising a descriptive error) would make the typing story much clearer and eliminate a large class of latent `NoneType` failures.
- Many helpers reach into `accessor.game_state.extra[...]` directly (e.g. `behavior_libraries/crafting_lib/recipes.py:54-63`), duplicating the weak typing issues from the core infrastructure. Centralizing these lookups in one accessor module (with real types) would let the behavior libraries stay agnostic of storage details.

## tests
- The infrastructure suite uses a hand-rolled `MockState` that only exposes `.extra` and then sprinkles `# type: ignore[arg-type]` on nearly every helper call (`tests/infrastructure/test_phase1_commitment.py:41-120`). Defining a minimal `Protocol` for the state dependency (e.g., `SupportsExtra = Protocol: extra: dict[str, Any]`) or instantiating a real `GameState` fixture would let the tests run under mypy without suppressions and would exercise the real types the helpers expect.
- Unit tests for the core accessor (`tests/test_phase3.py:74-143`) also rely on raw string actor IDs and never touch the `ActorId` constructors, so regressions in the typed API would go unnoticed. Extending these tests to use the `ActorId` wrappers (or at least asserting that `StateAccessor` accepts them) would increase coverage of the type-safe path you expect engine authors to use.

## examples
- Several example behaviors, notably `examples/spatial_game/behaviors/magic_star.py:14-62`, advertise the signature `(entity, accessor, context)` and call `accessor.get_actor(...)`, but the engine will actually pass a `GameState` object. As soon as a user copies this example into a live build, it raises `AttributeError`. Please either update the examples to follow the `(entity, state, context)` contract or change `BehaviorManager` to pass the accessor so the sample code works.
